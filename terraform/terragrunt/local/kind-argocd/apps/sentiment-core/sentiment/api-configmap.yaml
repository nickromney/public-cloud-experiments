apiVersion: v1
kind: ConfigMap
metadata:
  name: sentiment-api
  namespace: sentiment
  labels:
    app.kubernetes.io/name: sentiment-api
    app.kubernetes.io/component: backend
data:
  server.js: |
    const http = require('node:http');
    const { promises: fs } = require('node:fs');
    const path = require('node:path');

    const PORT = Number.parseInt(process.env.PORT || '8080', 10);
    const DATA_DIR = process.env.DATA_DIR || '/data';
    const CSV_PATH = path.join(DATA_DIR, 'ratings.csv');
    const OLLAMA_URL = (process.env.OLLAMA_URL || 'http://ollama.sentiment-llm.svc.cluster.local:11434').replace(/\/$/, '');
    const OLLAMA_MODEL = process.env.OLLAMA_MODEL || 'qwen2.5:0.5b';
    const OLLAMA_PULL_ON_DEMAND = (process.env.OLLAMA_PULL_ON_DEMAND || 'true').toLowerCase() === 'true';

    function json(res, status, body) {
      const payload = JSON.stringify(body);
      res.writeHead(status, {
        'Content-Type': 'application/json; charset=utf-8',
        'Content-Length': Buffer.byteLength(payload),
      });
      res.end(payload);
    }

    function notFound(res) {
      json(res, 404, { error: 'not_found' });
    }

    async function readJsonBody(req) {
      const chunks = [];
      let total = 0;
      for await (const chunk of req) {
        total += chunk.length;
        if (total > 1024 * 1024) {
          const err = new Error('payload_too_large');
          err.statusCode = 413;
          throw err;
        }
        chunks.push(chunk);
      }
      const raw = Buffer.concat(chunks).toString('utf8');
      if (!raw.trim()) return {};
      try {
        return JSON.parse(raw);
      } catch {
        const err = new Error('invalid_json');
        err.statusCode = 400;
        throw err;
      }
    }

    async function ensureCsvExists() {
      await fs.mkdir(DATA_DIR, { recursive: true });
      try {
        await fs.access(CSV_PATH);
      } catch {
        const header = 'timestamp,label,confidence,latency_ms,text\n';
        await fs.writeFile(CSV_PATH, header, 'utf8');
      }
    }

    async function fetchJson(url, payload, timeoutMs = 120000) {
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), timeoutMs);
      try {
        const res = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
          signal: controller.signal,
        });
        const text = await res.text();
        let data;
        try {
          data = text ? JSON.parse(text) : null;
        } catch {
          data = { raw: text };
        }
        if (!res.ok) {
          const err = new Error(`upstream_${res.status}`);
          err.statusCode = 502;
          err.details = data;
          throw err;
        }
        return data;
      } finally {
        clearTimeout(timer);
      }
    }

    async function ensureModelAvailable() {
      try {
        await fetchJson(`${OLLAMA_URL}/api/show`, { name: OLLAMA_MODEL }, 15000);
        return;
      } catch (e) {
        if (!OLLAMA_PULL_ON_DEMAND) throw e;
      }

      // /api/pull streams JSON lines; we only need to wait for completion.
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), 10 * 60 * 1000);
      try {
        const res = await fetch(`${OLLAMA_URL}/api/pull`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: OLLAMA_MODEL }),
          signal: controller.signal,
        });
        const body = await res.text();
        if (!res.ok) {
          const err = new Error(`ollama_pull_failed_${res.status}`);
          err.statusCode = 502;
          err.details = body;
          throw err;
        }
      } finally {
        clearTimeout(timer);
      }
    }

    function normalizeLabel(label) {
      const v = String(label || '').toLowerCase().trim();
      if (v === 'positive' || v === 'pos') return 'positive';
      if (v === 'negative' || v === 'neg') return 'negative';
      return null;
    }

    async function analyzeSentiment(text) {
      await ensureModelAvailable();
      const prompt = [
        'You are a sentiment classifier.',
        'Return ONLY valid JSON like: {"label":"positive"|"negative","confidence":0.0-1.0}.',
        'No markdown. No extra keys.',
        'Text:',
        '"""',
        text,
        '"""',
      ].join('\n');

      const start = Date.now();
      const result = await fetchJson(`${OLLAMA_URL}/api/generate`, {
        model: OLLAMA_MODEL,
        prompt,
        stream: false,
        format: 'json',
        options: { temperature: 0 },
      });
      const latencyMs = Date.now() - start;

      let parsed;
      try {
        parsed = JSON.parse(result.response);
      } catch {
        parsed = null;
      }

      let label = normalizeLabel(parsed?.label);
      let confidence = typeof parsed?.confidence === 'number' ? parsed.confidence : null;

      if (!label) {
        const match = String(result.response || '').match(/\b(positive|negative)\b/i);
        label = match ? normalizeLabel(match[1]) : null;
      }
      if (!label) {
        label = 'negative';
        confidence = confidence ?? 0.5;
      }
      if (confidence == null || Number.isNaN(confidence)) confidence = 0.5;
      if (confidence < 0) confidence = 0;
      if (confidence > 1) confidence = 1;

      return { label, confidence, latency_ms: latencyMs };
    }

    function csvEscape(value) {
      const s = String(value ?? '');
      const escaped = s.replaceAll('"', '""');
      return `"${escaped}"`;
    }

    function parseCsvLine(line) {
      // Minimal CSV parser for our own quoted format.
      const out = [];
      let i = 0;
      while (i < line.length) {
        if (line[i] === ',') {
          out.push('');
          i += 1;
          continue;
        }
        if (line[i] !== '"') {
          // unquoted
          let j = i;
          while (j < line.length && line[j] !== ',') j += 1;
          out.push(line.slice(i, j));
          i = j + 1;
          continue;
        }
        // quoted
        i += 1;
        let buf = '';
        while (i < line.length) {
          if (line[i] === '"' && line[i + 1] === '"') {
            buf += '"';
            i += 2;
            continue;
          }
          if (line[i] === '"') {
            i += 1;
            break;
          }
          buf += line[i];
          i += 1;
        }
        out.push(buf);
        if (line[i] === ',') i += 1;
      }
      return out;
    }

    async function listComments(limit = 50) {
      await ensureCsvExists();
      const raw = await fs.readFile(CSV_PATH, 'utf8');
      const lines = raw.split(/\r?\n/).filter(Boolean);
      if (lines.length <= 1) return [];
      const rows = lines.slice(1).reverse().slice(0, limit);
      const items = [];
      for (const line of rows) {
        const [timestamp, label, confidence, latency_ms, text] = parseCsvLine(line);
        items.push({
          timestamp,
          label,
          confidence: Number.parseFloat(confidence),
          latency_ms: Number.parseInt(latency_ms, 10),
          text,
        });
      }
      return items;
    }

    async function handle(req, res) {
      try {
        if (req.method === 'GET' && req.url === '/healthz') {
          await ensureCsvExists();
          json(res, 200, { ok: true });
          return;
        }

        if (req.method === 'GET' && req.url?.startsWith('/api/v1/comments')) {
          const url = new URL(req.url, 'http://localhost');
          const limit = Number.parseInt(url.searchParams.get('limit') || '50', 10);
          json(res, 200, { items: await listComments(Number.isFinite(limit) ? limit : 50) });
          return;
        }

        if (req.method === 'POST' && req.url === '/api/v1/analyze') {
          const body = await readJsonBody(req);
          const text = String(body.text || '').trim();
          if (!text) {
            json(res, 400, { error: 'text_required' });
            return;
          }
          const analysis = await analyzeSentiment(text);
          json(res, 200, { ...analysis });
          return;
        }

        if (req.method === 'POST' && req.url === '/api/v1/comments') {
          const body = await readJsonBody(req);
          const text = String(body.text || '').trim();
          if (!text) {
            json(res, 400, { error: 'text_required' });
            return;
          }
          const analysis = await analyzeSentiment(text);
          const timestamp = new Date().toISOString();
          await ensureCsvExists();
          const line = [
            csvEscape(timestamp),
            csvEscape(analysis.label),
            csvEscape(analysis.confidence.toFixed(3)),
            csvEscape(String(analysis.latency_ms)),
            csvEscape(text),
          ].join(',');
          await fs.appendFile(CSV_PATH, `${line}\n`, 'utf8');
          json(res, 201, { timestamp, text, ...analysis });
          return;
        }

        notFound(res);
      } catch (e) {
        const status = e?.statusCode || 500;
        json(res, status, { error: e?.message || 'error', details: e?.details });
      }
    }

    const server = http.createServer(handle);
    server.listen(PORT, '0.0.0.0', async () => {
      await ensureCsvExists();
      // eslint-disable-next-line no-console
      console.log(`sentiment-api listening on :${PORT}, model=${OLLAMA_MODEL}, ollama=${OLLAMA_URL}`);
    });
